Note: The following was generated by Gemini CLI given the following prompt:
 Read the @extensions/inkex/transforms.py module source code and provide a summary of its key classes and functions
│related to SVG transformations.

Based on the source code of extensions/inkex/transforms.py, here is a summary of its key classes and functions related to
  SVG transformations:

  The module provides a set of classes and functions to parse, manipulate, and apply SVG transformations. It is central to
  handling the positioning, scaling, and rotation of objects within Inkscape extensions.

  Key Classes:

   1. `Transform`:
       * Purpose: This is the core class for representing and manipulating 2D affine transformations (like those found in an
         SVG transform attribute).
       * Initialization: It's highly versatile and can be created from:
           * An SVG transform string (e.g., "translate(10, 20) scale(2)").
           * A 6-element tuple (a, b, c, d, e, f) corresponding to matrix(a,b,c,d,e,f).
           * Another Transform object.
       * Internal Representation: Internally, it uses a representation based on complex numbers for performance, which is
         particularly efficient when applying transformations to many points (e.g., in a path).
       * Key Methods:
           * add_translate(), add_scale(), add_rotate(), add_skewx(), add_skewy(): Methods to compose the transformation by
             adding new operations.
           * apply_to_point() / capply_to_point(): Applies the transformation to a given point (vector or complex number).
           * __matmul__ (@ operator): Allows for composing transformations by multiplying Transform objects together.
           * __neg__ (- operator): Returns the inverse of the transformation.
           * to_hexad(): Returns the transformation as a 6-element tuple for SVG output.
           * is_translate(), is_scale(), is_rotate(): Checks if the transform consists of only a single type of operation.

   2. `Vector2d` and `ImmutableVector2d`:
       * Purpose: Represent a 2D vector or point in Euclidean space. Vector2d is mutable, while ImmutableVector2d is not.
       * Functionality: They support standard vector operations:
           * Addition, subtraction, scalar multiplication/division.
           * dot() and cross() products.
           * length and angle properties.
           * Conversion to and from other types like tuples and complex numbers.

   3. `BoundingBox`:
       * Purpose: Represents an axis-aligned bounding box, defined by two BoundingInterval objects (one for x and one for y).
       * Functionality:
           * Calculates properties like width, height, center, top, left.
           * Supports operations like union (+ or |) and intersection (&).
           * Can be resized (resize()) or created from (x, y, width, height) values.
           * anchor_distance(): A utility method to calculate a sortable distance value from an anchor point, useful for
             ordering objects.

   4. `DirectedLineSegment`:
       * Purpose: Represents a line segment with a defined start and end point.
       * Functionality:
           * Calculates length and angle.
           * intersect(): Finds the intersection point with another line segment.
           * distance_to_point(): Calculates the shortest distance from the segment to a point.
           * point_at_ratio(): Finds the coordinates of a point at a certain fraction of the segment's length.

  Key Functions:

   * `cubic_extrema(py0, py1, py2, py3)` and `quadratic_extrema(py0, py1, py2)`:
       * Purpose: These are utility functions used to find the minimum and maximum coordinate values (the extrema) of a 1D
         cubic or quadratic Bézier curve. They are essential for accurately calculating the bounding box of a curved path
         segment.
